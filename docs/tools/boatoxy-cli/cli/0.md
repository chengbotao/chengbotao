---
title: CLI
icon: page
author: ChengBotao
date: 2023-03-29 19:37:47
category:
  - Tools
tag:
  - 前端工程化-CLI
---

<!--
 * @description: CLI
 * @Author: ChengBotao
 * @Date: 2023-03-29 19:37:47
-->

## checkNodeVersion

> 期望使用的 NodeJS 版本检查  

```ts
import semver from "semver";
import chalk from "chalk"

/**
 * @description: 期望使用的 NodeJS 版本检查
 * @param {string | semver.Range} range 
 * @param {string} packageName 
 * @param {boolean} optionsOrLoose 
 * @return {*}
 */
export default function checkNodeVersion(range: string | semver.Range, packageName: string, optionsOrLoose: boolean | semver.RangeOptions = { includePrerelease: true }) {
    if (!semver.satisfies(process.version, range, optionsOrLoose)) {
        console.log(chalk.red(
            `You are using Node ${process.version}, but this version of ${packageName} requires Node ${range}.

Please upgrade your Node version.`
        ))
        process.exit(1)
    }
}
```

## suggestCommands

> 未知命令的推荐(错误命令,猜测用户意图)

```ts
import chalk from "chalk";
import { Command } from "commander";
import leven from "leven";

/**
 * @description: 未知命令的推荐(错误命令,猜测用户意图)
 * @param {Command} program
 * @param {string} unknownCommand
 * @return {*}
 */
export default function suggestCommands(program: Command, unknownCommand: string) {
    const availableCommands = program.commands.map(cmd => cmd.name())

    let suggestion: any;
    availableCommands.forEach(cmd => {
        const isBestMatch = leven(cmd, unknownCommand) < leven(suggestion || '', unknownCommand)
        if (leven(cmd, unknownCommand) < 3 && isBestMatch) {
            suggestion = cmd
        }
    })

    if (suggestion) {
        console.log(`  ` + chalk.red(`Did you mean ${chalk.yellow(suggestion)}?`))
    }
}
```

## resolvePkg

> 读取指定目录下 package.json 文件


```ts
import fs from "fs-extra";
import path from "path";
import { readPackageSync } from "read-pkg"

/**
 * @description: 读取指定目录下 package.json 文件
 * @param {string} dir 路径
 * @return {*}
 */
export default function resolvePkg(dir: string) {
    if (fs.existsSync(path.join(dir, 'package.json'))) {
        return readPackageSync({ cwd: dir })
    }
    return {}
}
```

## writeFileTree

> 将内存中内容写入文件

```ts
import fs from "fs-extra"
import path from "path"

/**
 * @description: 写文件
 * @param {string} dir
 * @param {Record} files
 * @param {*} string
 * @return {*}
 */
export default async function writeFileTree(dir: string, files: Record<string, string | NodeJS.ArrayBufferView>) {
    Object.keys(files).forEach((name) => {
        const filePath = path.join(dir, name)
        // 确认需写入的文件存在,不存在直接新建
        fs.ensureDirSync(path.dirname(filePath))
        fs.writeFileSync(filePath, files[name])
    })
}
```